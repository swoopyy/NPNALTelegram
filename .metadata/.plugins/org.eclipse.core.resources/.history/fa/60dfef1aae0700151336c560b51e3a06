package npnets.simulator.handlers;

import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Timer;
import java.util.TimerTask;

import npnets.simulator.exceptions.NoBindingAvaliableException;
import npnets.simulator.simulate.MarkingAdapter;
import npnets.simulator.simulate.Report;
import npnets.simulator.simulate.Simulator;
import npnets.simulator.simulate.TimeBound;

import org.eclipse.core.commands.ExecutionEvent;
import org.eclipse.core.commands.AbstractHandler;
import org.eclipse.core.commands.ExecutionException;
import org.eclipse.core.commands.IHandler;
import org.eclipse.jface.dialogs.InputDialog;
import org.eclipse.jface.window.Window;
import org.eclipse.ui.PlatformUI;

import ru.mathtech.npntool.npnets.highlevelnets.hlpn.Transition;

public class NPNGraphicalSimulatorCMSimulateHandler extends AbstractHandler implements IHandler {
	Simulator sim = new Simulator();
	double steps;
	private Map<Transition, Long> timeMap=new HashMap<Transition, Long>();
	private Map<Transition, TimeBound> timeBounds=new HashMap<Transition, TimeBound>(); 
	Date cancelDate=null;
	long prevTime;
	@Override
	public Object execute(ExecutionEvent event) throws ExecutionException {
		sim.userBindings=false;
		Simulator.userDriven=false;
		final Timer timer=new Timer();
		TimerTask timerTask=new TimerTask() {
			
			@Override
			public void run() {
				Date dt=new Date(scheduledExecutionTime());
				Report report=new Report();
				report.appendLineToReport("Scheduled operation was made at time: " + (prevTime==0?0:scheduledExecutionTime()-prevTime) );
				prevTime=scheduledExecutionTime();
				report.putToLog();
				if(dt.compareTo(cancelDate)==1)
					timer.cancel();
				
			}
		};
		InputDialog sd = new InputDialog(PlatformUI.getWorkbench().getDisplay().getActiveShell(), "Choose time", "The duration of the simulation (in sec): ", "10",
				null);
		if (sd.open() == Window.OK) {
			if (sd.getValue() != null) {
				steps = new Double(sd.getValue());
				cancelDate=new Date((long) (new Date().getTime()+steps*1000));
				//timer.
					try {
						timer.schedule(timerTask, 0, 100);
						//MarkingAdapter ma = sim.makeTransitions(null);
						//sim.setMarking(ma);
					} catch (Exception e) {
						new Report().appendLineToReport("Deadlock appeared on step " + steps);
						e.printStackTrace();
					}
			}
		}
		return null;
	}
	private void assignTimes(List<Transition> transitions){
		for(Transition tr:transitions)
		{
			if(!timeMap.containsKey(tr)){
				timeMap.put(tr, calculateTime(timeBounds.get(tr)));
			}
		}
	}
	private Long calculateTime(TimeBound tb) {
		return (long) (new Random().nextInt((int) (tb.getUpper()*1000-tb.getLower()*1000))+tb.getLower()*1000);
	}
	private void fillTimeBounds(List<Transition> transitions,double elapsedTime){
		Map<Transition, TimeBound> tempMap=new HashMap<Transition, TimeBound>();
		tempMap.putAll(timeBounds);
		timeBounds.clear();
		for(Transition tr:transitions)
		{
			if(tempMap.containsKey(tr)){
				TimeBound tb=tempMap.get(tr);
				tb.setLower((tb.getLower()-elapsedTime));
				if(tb.getLower()<0)
					tb.setLower(0);
				tb.setLower((tb.getLower()-elapsedTime));
				timeBounds.put(tr, tb);
			}
			else
				timeBounds.put(tr, new TimeBound(tr.getFirstTimeConstraint(), tr.getSecondTimeConstraint()));			
		}
		tempMap.clear();
	}

}
